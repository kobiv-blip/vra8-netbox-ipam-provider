"""
Copyright (c) 2020 VMware, Inc.

Modified for NetBox by Ryan Hinson (@rnhinson)

This product is licensed to you under the Apache License, Version 2.0 (the "License").
You may not use this product except in compliance with the License.

This product may include a number of subcomponents with separate copyright notices
and license terms. Your use of these subcomponents is subject to the terms and
conditions of the subcomponent's license, as noted in the LICENSE file.
"""
import requests
from vra_ipam_utils.ipam import IPAM
import logging
from requests.packages import urllib3
import ipaddress

def handler(context, inputs):
    ipam = IPAM(context, inputs)
    IPAM.do_get_ip_ranges = do_get_ip_ranges
    return ipam.get_ip_ranges()

def do_get_ip_ranges(self, auth_credentials, cert):
    try:
        endpoint_props = self.inputs.get("endpoint", {}).get("endpointProperties", {})
        ignore_ssl = str(endpoint_props.get("ignore_ssl", "false"))
        verify = False if ignore_ssl.lower() == "true" else True
        if not verify:
            urllib3.disable_warnings(category=urllib3.exceptions.InsecureRequestWarning)
    except Exception as e:
        raise Exception("Error handling SSL verification setting: " + str(e))

    netbox_object = endpoint_props.get("netboxObject")
    netbox_tag = endpoint_props.get("netboxTag")
    netbox_url = endpoint_props.get("hostName")
    netbox_site = endpoint_props.get("netboxSite")

    if not all([netbox_object, netbox_url, netbox_site]):
        raise Exception("Missing required NetBox properties: object, URL, or site.")

    username = auth_credentials.get("privateKeyId")
    token = auth_credentials.get("privateKey")
    headers = {"Authorization": f"Token {token}"}

    logging.info("Collecting ranges")

    response = requests.get(f"{netbox_url}/api/ipam/{netbox_object}/?site={netbox_site}", verify=verify, headers=headers)
    r = response.json().get("results", [])
    result_ranges = []
    print(r)

    if netbox_object == "prefixes":
        for prefix in r:
            try:
                subnet_str = prefix.get("prefix")
                if not subnet_str:
                    continue
                subnet = ipaddress.ip_network(str(subnet_str))

                vlan = prefix.get("vlan") or {}
                vlan_name = vlan.get("name", "unknown")

                network_range = {
                    "id": str(prefix.get('id', '')),

                    "name": vlan_name,

                    "startIPAddress": str(subnet[4]),

                    "endIPAddress": str(subnet[-4]),

                    "ipVersion": "IPv4",

                    "subnetPrefixLength": str(subnet.prefixlen),

                    "gatewayAddress": str(subnet[1]),
                }

                if "domain" in endpoint_props:
                    network_range["domain"] = endpoint_props["domain"]
                else:
                    logging.info(f"Domain variable not set. Ignoring.")

                result_ranges.append(network_range)

            except Exception as e:
                logging.warning("Failed to process prefix: %s" % str(e))

    else:
        for ip_range in r:
            try:
                start_addr = ip_range.get("start_address")
                end_addr = ip_range.get("end_address")
                if not start_addr or not end_addr:
                    continue

                subnet = ipaddress.ip_interface(str(start_addr)).network
                family = ip_range.get("family") or {}
                ip_version = family.get("label", "unknown")

                network_range = {
                    "id": str(ip_range.get("id", '')),

                    "name": str(ip_range.get("display", '')),

                    "startIPAddress": str(start_addr.split('/')[0]),

                    "endIPAddress": str(end_addr.split('/')[0]),

                    "ipVersion": ip_version,

                    "subnetPrefixLength": str(subnet.prefixlen),

                    "gatewayAddress": str(subnet[1]),
                }

                if "domain" in endpoint_props:
                    network_range["domain"] = endpoint_props["domain"]
                else:
                    logging.info(f"Domain variable not set. Ignoring.")

                result_ranges.append(network_range)

            except Exception as e:
                logging.warning("Failed to process IP range: %s" % str(e))

    return {
        "ipRanges": result_ranges
    }
